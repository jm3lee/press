#!/usr/bin/env python3
"""
This module provides Jinja2 filters to transform Markdown-style links by
capitalizing their text in various ways, and a CLI entry point to render
a Jinja2 template with a dynamic link map.

Filters:
    - linktitle: Capitalize the first letter of each word in the link text.
    - linkcap: Capitalize only the first letter of the entire link text.
"""

import sys
import re
import json
from typing import Any, Dict, Mapping

from jinja2 import Environment, FileSystemLoader, StrictUndefined
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('render_template')

# Precompile regex patterns for performance
_WHITESPACE_WORD_PATTERN = re.compile(r"(\S+)")
_LINK_PATTERN = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

# Default link map entries
linkmap: Dict[str, str] = {
    "home": "[home](/index.html)",
    "flag_france": "\U0001F1EB\U0001F1F7",
    "flag_russia": "\U0001F1F7\U0001F1FA",
    "flag_usa": "\U0001F1FA\U0001F1F8",
}


def linktitle(value: Any) -> Any:
    """
    Capitalize the first character of *each* word in the link text,
    preserving **all** whitespace (spaces, tabs, newlines).

    Args:
        value: The value to be filtered. If not a string or not in link
            Markdown format, it is returned unchanged.

    Returns:
        The transformed string with each word's first character capitalized,
        or the original value if no transformation was applicable.
    """
    if not isinstance(value, str):
        return value

    match = _LINK_PATTERN.match(value)
    if not match:
        return value

    link_text, url = match.group(1), match.group(2)

    def _capitalize_word(m: re.Match) -> str:
        word = m.group(1)
        return word[0].upper() + word[1:]

    transformed = _WHITESPACE_WORD_PATTERN.sub(_capitalize_word, link_text)
    return f"[{transformed}]({url})"


def linkcap(value: Any) -> Any:
    """
    Capitalize only the first character of the link text,
    preserving all other characters and whitespace.

    Args:
        value: The value to be filtered. If not a string or not in link
            Markdown format, it is returned unchanged.

    Returns:
        The transformed string with its first character capitalized,
        or the original value if no transformation was applicable.
    """
    if not isinstance(value, str):
        return value

    match = _LINK_PATTERN.match(value)
    if not match:
        return value

    link_text, url = match.group(1), match.group(2)
    if not link_text:
        return value

    transformed = link_text[0].upper() + link_text[1:]
    return f"[{transformed}]({url})"


def main(argv: list[str]) -> None:
    """
    Load metadata from a JSON file to update the link map, then render
    a Jinja2 template with the combined context.

    Usage:
        ./script.py metadata.json template_name

    Args:
        argv: Command-line arguments (excluding the script name). Should
            contain two elements: the path to the JSON metadata file and
            the Jinja2 template name located under `/data`.
    """

    metadata_path, template_name = argv

    env = Environment(
        loader=FileSystemLoader("/data"),
        undefined=StrictUndefined
    )
    env.filters["linktitle"] = linktitle
    env.filters["linkcap"] = linkcap

    with open(metadata_path, "r", encoding="utf-8") as metadata_file:
        metadata: Mapping[str, Mapping[str, str]] = json.load(metadata_file)
        for key, meta in metadata.items():
            text = meta.get("linktext", "")
            url = meta.get("url", "")
            linkmap[key] = f"[{text}]({url})"

    template = env.get_template(template_name)
    rendered = template.render(**linkmap)
    print(rendered)


if __name__ == "__main__":
    main(sys.argv[1:])
    sys.exit(0)

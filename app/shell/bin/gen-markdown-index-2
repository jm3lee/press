#!/usr/bin/env python3

import os
import yaml
import warnings

# Tracks the depth of directory traversal for indentation
level = 0

def extract_metadata(filepath):
    """
    Load and return YAML metadata from the given file.

    Args:
        filepath (str): Path to the YAML file.

    Returns:
        dict or None: Parsed metadata dictionary, or None if invalid.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except Exception as e:
        warnings.warn(f"Invalid YAML: {filepath} ({e})")
        return None

def visit(directory):
    for filename in os.listdir(directory):
        try:
            p = os.path.join(directory, filename)
            if os.path.isdir(p):
                if os.path.isfile(os.path.join(p, 'index.yml')):
                    meta = extract_metadata(os.path.join(p, 'index.yml'))
                    yield (meta['id'], meta['title'], p)
            elif os.path.isfile(p) and p.endswith('.yml') and not p.endswith("/index.yml"):
                meta = extract_metadata(p)
                yield (meta['id'], meta['title'], p)
        except Exception as e:
            warnings.warn(f"Failed to process {p}")
            raise

def print_index_entry(directory):
    """
    Print the index entry for a directory, if index.md and index.yml exist.

    Args:
        directory (str): Path to the directory.
    """
    index_md = os.path.join(directory, 'index.md')
    index_yml = os.path.join(directory, 'index.yml')
    if os.path.isfile(index_md) and os.path.isfile(index_yml):
        meta = extract_metadata(index_yml)
        if meta:
            entry_id = meta.get('id')
            entry_title = meta.get('title')
            if entry_id and entry_title:
                print('  ' * level + f'- {{{{{entry_id}|linktitle}}}}')
            else:
                warnings.warn(f"Missing 'id' in: {index_yml}")

def process_dir(directory):
    """
    Recursively process a directory tree to print structured link entries.

    Args:
        directory (str): Path to the current directory.
    """
    global level
    for entry in sorted(list(visit(directory)), key=lambda x: x[1].lower()):
        entry_id = entry[0]
        print('  ' * level + f'- {{{{{entry_id}|linktitle}}}}')
        entry_path = entry[2]
        if os.path.isdir(entry_path):
            level += 1
            process_dir(entry_path)
            level -= 1

if __name__ == '__main__':
    import sys
    root_dir = sys.argv[1] if len(sys.argv) > 1 else '.'
    process_dir(root_dir)
